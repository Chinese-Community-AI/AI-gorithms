This will resolve:
102.Binary Tree Level Order Traversal 
144.Binary Tree Preorder Traversal 
145.Binary Tree Postorder Traversal 
94.Binary Tree Inorder Traversal 

## One Sentence Summary 
There are only two ways to traverse a binary tree: recursive traversal and level-order traversal. 
1. Recursive traversal leads to DFS algorithms. 
2. Level-order traversal leads to BFS algorithms.

The order of recursive traversal in a binary tree is fixed, but there are three key places to insert code. Placing code in different positions will produce different effects. 
The order of level-order traversal is also fixed, but there are three different ways to write it, suitable for different situations. 

Binary Tree Traversal: 
-Recursive Traversal (DFS) Three special positions, code runs at different times
-Level-order Traveral (BFS) Three different ways, for different scenarios 

Recursive Traversal (DFS): 
- Preorder position 
- Inorder postion 
- Postorder position 

Level-order Travesal (BFS): 
- First way is the simplest cannot record depth 
- Second way is most common can record depth 
- Third way is the most flexible Good for complex problems 

After learning basic concepts of binary trees and special types of binary trees, this article will show you how to traverse and visi nodes in a binary tree.
There are two main traversal algorithms for binary trees: recursive traversal and level-order traversal. Each has a code template. The recursive template can be used for later DFS and backtracking algorithms. The level-order template can be used for BFS algorithms. That's why I often say binary tree structures are very important. 

Preorder, inorder, and postorder traverals are all recursive traversals. The difference is just where you put your custom code in the template. This will be explained with visual panel. 

## Recursive Traversal (DFS) 
Here is the code template for recursive traveral of a binary tree: 

```python
#basic binary tree node 
class TreeNode: 
    def __init__(self, val=0, left=None, right=None):
        self.val = val
        self.left = left
        self.right = right

# recursive traversal framework for binary tree
def traverse(root: TreeNode):

    if root is None:
        return 

    traverse(root.left)
    traverse(root.right)
```
Why can this short and simple code traverse a binary tree? In what order does it visit the nodes?
You can think of the traverse recursive function as a pointer moving around the binary tree. The visualization panel shows how this algorithm works step by step. 

Open this panel. On the right, the root pointer shows the current node for the traverse function. You can click the line console.log ("enter" several times to watch how the root pointer moves through the tree):

The order is: always go left first until you hit a null pointer and can't go further, then try to go right once; then keep going left again, and so on. If both left and right are done, return to the parent node. 

From the code, you can see that root.left is called first, then root.right. Each time the traverse function is called, it goes to the left child first, until it cannot go furthur, then it tries the right child.

Now, let's try a small change. If we modify the traverse function to call root.right first, then root.left, what will happen?

```python 
# Modify the standard binary tree traversal framework
def traverseFlip(root: TreeNode) -> None:
    if root is None:
        return 
    # traverse the right subtree first, then traverse the left subtree
    traverseFlip(root.right)
    traverseFlip(root.left)
```

The traverseFlip function also visits all nodes in the tree, but the order is the opposite of the standard traverse function. 

This example shows:

The order of recursive traversal (the way the root moves through the tree) only depends on the order of the left and right recursive calls, and nothing else.

Normally, we don't traverse a binary tree like traverseFlip. By default, we use the left-first, right second order. So when we talk about the code template for tree traversal, we mean left first, right second:

```python
#basic binary tree node
class TreeNode:
    def __init__(self, val = 0, left = None, right= None):
        self.val = val
        self.left = left
        self.right = right

# recursive traversal framwork for binary tree
def traverse (root: TreeNode):
    if root is None:
        return 
    traverse(root.left)
    traverse(root.right)
```

As long as this left-first, right-second order doesn't change, the order in which traverse visits the nodes is fixed, no matter how many extra lines you add.

Some readers with data structure background may feel confused:
Wait, if you have taken a data structure course, you know binary trees have preorder, inorder, and postorder traversals, which give different orders. Why do you say the recursive traversal order is fixed?

## Understanding Preorder, Inorder, and Postorder Traversal
The order of recursive traversal, that is the order in which the traverse fucntion visits nodes, is fixed. As shown in the visual panel, the root poitner moves around the tree in a fixed order:

However, where you write your code inside the traverse function can make a difference. THe results of preorder, inorder, and postorder traversals are different because you place the code at different positions in the function. 

For example, when you just enter a ndoe, you do not know anything about its child nodes. But when you are about to leave a node, all its child nodes have been visited. So, code written in these two situations will behave differently. 

Preorder, inorder and postorder traversal are really about where you put your code in the binary tree traversal framework: 

```python
# Binary tree traversal framework
def traverse(root):
    if root is None:
        return 
    # Pre-order position
    traverse(root.left)
    # In-order position
    traverse(root.right)
    # Post-order position
```

### The key insight: This framework shows that there are three strategic positions where you can insert your logic:
1. pre-order postion (before recursion): Access node before its children
2. In-order position (between recursions): Access node between left and right children
3. Post-order position (after recursion): Access node after its chilfren 

In practice, you'd typically only use one of these positions depending on your needs:

```python
# Pre-order: process root first
def preorder(root):
    if not root: return
    process(root) # Do something here
    preorder(root.left)
    preorder(root.right)

# In-order: process root in middle
def inorder(root):
    if not root: return 
    preorder(root.left)
    process(root) # Do something here
    preorder(root.right)

# Post-order: process root last
def postorder(root):
    if not root: return
    postorder(root.left)
    postorder(root.right)
    process(root) # Do something here
```

The framework version is useful when you need to track information both going down the tree (pre-order) and combing back up (post-order), like calculating subtree sizes or heights.

The main difference between the three possitions is when the code is run.

In real algorithm problems, you won't just be asked to calculate preorder, inorder, or postorder results. You need to put the correct code in the correct position to solve probelms. So, you must fully understand what effect code in each position has to write accurate solutions.

Later, we will learn how to use preorder, inorder, and postorer postions for backtracking and dynamic programming.

One more important point: for Binary Search Trees (BST), the result of an inorder traversal is always sorted. This is a key property of BST.

## Level Order Traversal (BFS)
Level order traversal, as the name suggests, visits the binary tree level by level:
Level order traversal uses a queue. Depending on your needs, there are three common ways to write it. Let's look at them one by one.

##Method 1
This is the simplest way. Here is the code:

```python 
from collections import deque

def levelOrderTraverse(root):
    if root is None:
        return
    q = deque()
    q.append(root)
    while q:
        cur = q.popleft()
        # visit cur node
        print(cur.val)

        # add cur's left and right children to the queue
        if cur.left is not None:
            q.append(cur.left)
        if cur.right is not None:
            q.append(cur.right)
```

Pros and Cons of This Method
The biggest advantage is simplicity. Each time, you take the front nde fro mthe queue and add its left and right children to the queue.

The downside is you cannot know which level the current node is on. Knowing the node's level is often needed, for example, to collect nodes of each level or to calculate the minimum depth of the tree.

So, this method is simple but not used much. The enxt method is more common.


## Method 2
If you chage method 1 a bit, you get this version:
```python
from collections import deque

def levelOrderTraverse(root):
    if root is None:
        return
    q = deque()
    q.append(root)
    # record the current depth being traversed (root node is considered as level 1 )
    depth = 1

    while q:
        sz = len(q)
        for i in range(sz):
            cur = q.popleft()
            # visit cur node and know its depth 
            print(f"depth = {depth}, val = {cur.val}")

            # add cur's left and right children to the queue
            if cur.left is not None:
                q.append(cur.left)
            if cur.right is not None:
                q.append(cur.right)
        depth += 1
```

Notice the inner for loop in the code:

```java
int sz = q.size();
for (int i = 0; i < sz; i ++>) {
    ...
}
```
The variable i record the position of node cur in the current level. In most problems, you do not need i, so you can also write it like this:

```java
int sz = q.size()
while (sz --> 0) {
    ...
}
```

The queue length sz need to be saved before the loop starts. The length of the queue changes during the loop, so you cannot use q.size() directly in the loop condition.

You can open this visual panel and click on the line console.log to see how the cur variable moves through the tree.
You will see nodes visited level by level, from left to right

With this method, you can record the level of each node. It can solve problems like finding the minimum depth of a binary tree. This is the most common way to write level order traversal.


## Method 3
If method 2 is the most common, why do we need method 3? It is to prepare for more advanced topics later.

Now we are only talking about levle order traversal of binary trees. But level order traversal can also be used for N-ary trees, BFS of graphs, and the classic BFS brute-force algorithm.
So, let's extend a bit.

In method 2, each time we go down on level, we increase depth by 1. You can think of each edge as having a weight of 1. The depth of each node is the sum of edge weights from the root to that node. All nodes at the same level have the same depth.

Now, suppose each edge can have any weight, and you want to print the total path weight for each node during level order traversal. What should you do?

In this case, nodes on the same level may have different total weights. Just one depth variable is not enough.

Method 3 solves this problem. It adds a State class to method 1, so each node keeps track of its own total path weight. Here is the code:

```python
class State:
    def __init__(self, node, depth):
        self.node = node
        self.depth = depth 

def levelOrderTraverse(root):
    if root is None:
        return 
    q = deque()
    # the path weight sum of the root node is 1
    q.append(State(root, 1))
    
    while q:
        cur = q.popleft()
        # visit th4e cur node, and know its path weight sum
        print(f"depth = {cur.depth}, val = {cur.node.val}")
        
        # add the left and right child nodes of cur to the queue
        if cur.node.left is not None:
            q.append(State(cur.node.left, cur.depth + 1))
        if cur.node.right is not None:
            q.append(State(cur.node.right, cur.depth + 1))
            
        # add the left and right child ndoes of cur to the queeu
        if cur.node.left is not None:
            q.append(State(cur.node.left, cur.depth + 1))
        if cur.node.right is not None:
            q.append(State(cur.node.right, cur.depth + 1))
```

With this method, every node has its own depth variable. It is hte most flexible and can meet all BFS needs.
But you need to define a State class, which can be a bit troublesome. If not needed, jsut use method 2.

Soon you will learn that this kind of weighted edge problem belongs to graph algorithms. You will use this method in BFS exercises and Dijkstra's algorithm. 

There are only these two ways to traverse a binary tree. Ohter code may look different, but the core idea is always one of these two methods.

For example, you might see code that uses a stack to traverse a binary tree. But this is actually still recursive traversal; the stack just simulates the call stack.

Or, you might see code that uses recursion to visit each level. This is stil level order traversal, just writen differently.

In short, don't be fooled by appearances. There are just two ways to traverse a binary tree. Once you mater them with the following tutorials and exercises, brute-force algorithms will be easy for you.