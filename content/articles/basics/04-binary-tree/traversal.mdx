# Binary Tree Traversal

After learning basic concepts of binary trees and special types of binary trees, this article will show you how to traverse and visit nodes in a binary tree.

There are two main traversal algorithms for binary trees: **recursive traversal** and **level-order traversal**. Each has a code template. The recursive template can be used for later DFS and backtracking algorithms. The level-order template can be used for BFS algorithms. That's why I often say binary tree structures are very important.

Preorder, inorder, and postorder traversals are all recursive traversals. The difference is just where you put your custom code in the template. I will explain this with a visual panel below.

<div className="bg-[var(--sidebar-bg)] p-6 rounded-xl border border-[rgba(55,53,47,0.09)] my-8">
  <h3 className="text-lg font-bold mb-4 flex items-center gap-2">
    <span>One Sentence Summary</span>
  </h3>
  <p className="text-[15px] opacity-90 mb-6">
    There are only two ways to traverse a binary tree: **recursive traversal**
    (leads to DFS) and **level-order traversal** (leads to BFS).
  </p>

  <div className="overflow-x-auto">
    <table className="min-w-full text-sm">
      <thead>
        <tr className="border-b border-[rgba(55,53,47,0.09)]">
          <th className="py-2 text-left font-bold opacity-60">Type</th>
          <th className="py-2 text-left font-bold opacity-60">
            Methods / Positions
          </th>
          <th className="py-2 text-left font-bold opacity-60">Key Features</th>
        </tr>
      </thead>
      <tbody>
        <tr className="border-b border-[rgba(55,53,47,0.06)]">
          <td className="py-3 font-semibold" rowspan="3">
            Recursive (DFS)
          </td>
          <td className="py-3">Preorder position</td>
          <td className="py-3 opacity-80">Runs when entering a node</td>
        </tr>
        <tr className="border-b border-[rgba(55,53,47,0.06)]">
          <td className="py-3">Inorder position</td>
          <td className="py-3 opacity-80">
            Runs between left and right subtree
          </td>
        </tr>
        <tr className="border-b border-[rgba(55,53,47,0.06)]">
          <td className="py-3">Postorder position</td>
          <td className="py-3 opacity-80">Runs when leaving a node</td>
        </tr>
        <tr className="border-b border-[rgba(55,53,47,0.06)]">
          <td className="py-3 font-semibold" rowspan="3">
            Level-order (BFS)
          </td>
          <td className="py-3">Method 1: Basic</td>
          <td className="py-3 opacity-80">Simplest, cannot record depth</td>
        </tr>
        <tr className="border-b border-[rgba(55,53,47,0.06)]">
          <td className="py-3">Method 2: Level-by-level</td>
          <td className="py-3 opacity-80">Most common, can record depth</td>
        </tr>
        <tr>
          <td className="py-3">Method 3: State-based</td>
          <td className="py-3 opacity-80">Most flexible, for complex BFS</td>
        </tr>
      </tbody>
    </table>
  </div>
</div>

## Recursive Traversal (DFS)

Here is the code template for recursive traversal of a binary tree:

<CodeTabs
  tabs={[
    {
      label: "python",
      language: "python",
      code: `# basic binary tree node
class TreeNode:
    def __init__(self, val=0, left=None, right=None):
        self.val = val
        self.left = left
        self.right = right

# recursive traversal framework for binary tree

def traverse(root: TreeNode):
if root is None:
return # Pre-order position
traverse(root.left) # In-order position
traverse(root.right) # Post-order position`    },
    {
      label: "java",
      language: "java",
      code:`public class TreeNode {
int val;
TreeNode left, right;
}

void traverse(TreeNode root) {
if (root == null) return;
// Pre-order position
traverse(root.left);
// In-order position
traverse(root.right);
// Post-order position
}`    },
    {
      label: "javascript",
      language: "javascript",
      code:`function traverse(root) {
if (root === null) return;
// Pre-order position
traverse(root.left);
// In-order position
traverse(root.right);
// Post-order position
}`    },
    {
      label: "go",
      language: "go",
      code:`func traverse(root _TreeNode) {
if root == nil {
return
}
// Pre-order position
traverse(root.Left)
// In-order position
traverse(root.Right)
// Post-order position
}`    },
    {
      label: "cpp",
      language: "cpp",
      code:`void traverse(TreeNode_ root) {
if (root == nullptr) return;
// Pre-order position
traverse(root->left);
// In-order position
traverse(root->right);
// Post-order position
}`
}
]}
/>

Why can this short and simple code traverse a binary tree? In what order does it visit the nodes?

The order is: **always go left first until you hit a null pointer and can't go further, then try to go right once; then keep going left again, and so on. If both left and right are done, return to the parent node.**

From the code, you can see that `root.left` is called first, then `root.right`. Each time the `traverse` function is called, it goes to the left child first, until it cannot go further, then it tries the right child.

Now, let's try a small change. If we modify the `traverse` function to call `root.right` first, then `root.left`, what will happen?

<CodeTabs
  tabs={[
    {
      label: "python",
      language: "python",
      code: `# modify the standard binary tree traversal framework
def traverseFlip(root: TreeNode) -> None:
    if root is None:
        return
    # traverse the right subtree first, then traverse the left subtree
    traverseFlip(root.right)
    traverseFlip(root.left)`,
    },
    {
      label: "java",
      language: "java",
      code: `void traverseFlip(TreeNode root) {
    if (root == null) return;
    // traverse right first
    traverseFlip(root.right);
    traverseFlip(root.left);
}`,
    },
    {
      label: "javascript",
      language: "javascript",
      code: `function traverseFlip(root) {
    if (root === null) return;
    traverseFlip(root.right);
    traverseFlip(root.left);
}`,
    },
    {
      label: "go",
      language: "go",
      code: `func traverseFlip(root *TreeNode) {
    if root == nil {
        return
    }
    traverseFlip(root.Right)
    traverseFlip(root.Left)
}`,
    },
    {
      label: "cpp",
      language: "cpp",
      code: `void traverseFlip(TreeNode* root) {
    if (root == nullptr) return;
    traverseFlip(root->right);
    traverseFlip(root->left);
}`,
    },
  ]}
/>

The `traverseFlip` function also visits all nodes in the tree, but the order is the opposite of the standard `traverse` function.

The order of recursive traversal (the way the pointer moves through the tree) only depends on the order of the left and right recursive calls, and nothing else. Normally, we use the left-first, right-second order by default.

## Understanding Preorder, Inorder, and Postorder Traversal

The order of recursive traversal is fixed. However, where you write your code inside the `traverse` function can make a difference.

For example, when you just enter a node, you do not know anything about its child nodes. But when you are about to leave a node, all its child nodes have been visited. So, code written in these two situations will behave differently.

- **Preorder position**: Runs when you enter the node. Matches the order in which the pointer moves through the tree.
- **Inorder position**: Runs after the left subtree is done but before the right subtree starts. In BSTs, this visits nodes in sorted order.
- **Postorder position**: Runs after both left and right subtrees are finished, right before leaving the node. All child information is available here.

<div className="bg-[var(--sidebar-bg)] p-6 rounded-lg border border-[rgba(55,53,47,0.09)] font-mono my-6 text-[var(--foreground)] opacity-90 overflow-x-auto flex justify-center">
  <pre className="leading-tight whitespace-pre">
    # Binary tree traversal framework def traverse(root): if root is None:
    return # [1] Pre-order position traverse(root.left) # [2] In-order position
    traverse(root.right) # [3] Post-order position
  </pre>
</div>

In real algorithm problems, you won't just be asked to calculate preorder, inorder, or postorder results. You need to put the correct code in the correct position to solve problems.

## Level Order Traversal (BFS)

Earlier, we talked about recursive traversal, which uses the function call stack to traverse a binary tree. It visits the tree from left to right, column by column. Level order traversal visits the binary tree level by level.

Level order traversal uses a **queue**. Depending on your needs, there are three common ways to write it.

### Method 1: The Simplest Way

This is the most basic implementation using a queue.

<CodeTabs
  tabs={[
    {
      label: "python",
      language: "python",
      code: `from collections import deque

def levelOrderTraverse(root):
if root is None:
return
q = deque()
q.append(root)
while q:
cur = q.popleft() # visit cur node
print(cur.val)

        # add cur's left and right children to the queue
        if cur.left is not None:
            q.append(cur.left)
        if cur.right is not None:
            q.append(cur.right)`
    },
    {
      label: "java",
      language: "java",
      code: `void levelOrderTraverse(TreeNode root) {
    if (root == null) return;
    Queue<TreeNode> q = new LinkedList<>();
    q.offer(root);
    while (!q.isEmpty()) {
        TreeNode cur = q.poll();
        // visit cur node
        System.out.println(cur.val);
        if (cur.left != null) q.offer(cur.left);
        if (cur.right != null) q.offer(cur.right);
    }

}`    },
    {
      label: "javascript",
      language: "javascript",
      code:`function levelOrderTraverse(root) {
if (root === null) return;
let q = [root];
while (q.length > 0) {
let cur = q.shift();
console.log(cur.val);
if (cur.left) q.push(cur.left);
if (cur.right) q.push(cur.right);
}
}`    },
    {
      label: "go",
      language: "go",
      code:`func levelOrderTraverse(root *TreeNode) {
if root == nil {
return
}
q := []*TreeNode{root}
for len(q) > 0 {
cur := q[0]
q = q[1:]
// visit cur node
fmt.Println(cur.Val)
if cur.Left != nil { q = append(q, cur.Left) }
if cur.Right != nil { q = append(q, cur.Right) }
}
}`    },
    {
      label: "cpp",
      language: "cpp",
      code:`void levelOrderTraverse(TreeNode* root) {
if (root == nullptr) return;
queue<TreeNode*> q;
q.push(root);
while (!q.empty()) {
TreeNode\* cur = q.front();
q.pop();
// visit cur node
cout << cur->val << endl;
if (cur->left) q.push(cur->left);
if (cur->right) q.push(cur->right);
}
}`
}
]}
/>

**Pros and Cons:** The biggest advantage is simplicity. The downside is you cannot know which level the current node is on.

### Method 2: Level-by-Level (Most Common)

This version records the depth of each level, which is often needed in problems.

<CodeTabs
  tabs={[
    {
      label: "python",
      language: "python",
      code: `from collections import deque

def levelOrderTraverse(root):
if root is None:
return
q = deque()
q.append(root) # record the current depth being traversed
depth = 1

    while q:
        sz = len(q)
        for i in range(sz):
            cur = q.popleft()
            # visit cur node and know its depth
            print(f"depth = {depth}, val = {cur.val}")

            if cur.left is not None:
                q.append(cur.left)
            if cur.right is not None:
                q.append(cur.right)
        depth += 1`
    },
    {
      label: "java",
      language: "java",
      code: `void levelOrderTraverse(TreeNode root) {
    if (root == null) return;
    Queue<TreeNode> q = new LinkedList<>();
    q.offer(root);
    int depth = 1;
    while (!q.isEmpty()) {
        int sz = q.size();
        for (int i = 0; i < sz; i++) {
            TreeNode cur = q.poll();
            System.out.println("depth = " + depth + ", val = " + cur.val);
            if (cur.left != null) q.offer(cur.left);
            if (cur.right != null) q.offer(cur.right);
        }
        depth++;
    }

}`    },
    {
      label: "javascript",
      language: "javascript",
      code:`function levelOrderTraverse(root) {
if (root === null) return;
let q = [root];
let depth = 1;
while (q.length > 0) {
let sz = q.length;
for (let i = 0; i < sz; i++) {
let cur = q.shift();
console.log(\`depth = \${depth}, val = \${cur.val}\`);
if (cur.left) q.push(cur.left);
if (cur.right) q.push(cur.right);
}
depth++;
}
}`    },
    {
      label: "go",
      language: "go",
      code:`func levelOrderTraverse(root *TreeNode) {
if root == nil {
return
}
q := []*TreeNode{root}
depth := 1
for len(q) > 0 {
sz := len(q)
for i := 0; i < sz; i++ {
cur := q[0]
q = q[1:]
fmt.Printf("depth = %d, val = %d\\n", depth, cur.Val)
if cur.Left != nil { q = append(q, cur.Left) }
if cur.Right != nil { q = append(q, cur.Right) }
}
depth++
}
}`    },
    {
      label: "cpp",
      language: "cpp",
      code:`void levelOrderTraverse(TreeNode* root) {
if (root == nullptr) return;
queue<TreeNode*> q;
q.push(root);
int depth = 1;
while (!q.empty()) {
int sz = q.size();
for (int i = 0; i < sz; i++) {
TreeNode\* cur = q.front();
q.pop();
cout << "depth = " << depth << ", val = " << cur->val << endl;
if (cur->left) q.push(cur->left);
if (cur->right) q.push(cur->right);
}
depth++;
}
}`
}
]}
/>

**Important:** You must save the queue length `sz` before the inner loop starts, because the length changes as you add children.

### Method 3: State-based (Most Flexible)

This method wraps each node in a `State` object to track its own depth. This is useful when nodes at the same level might have different total path weights (e.g., in graph algorithms).

<CodeTabs
  tabs={[
    {
      label: "python",
      language: "python",
      code: `class State:
    def __init__(self, node, depth):
        self.node = node
        self.depth = depth

def levelOrderTraverse(root):
if root is None:
return
q = deque()
q.append(State(root, 1))

    while q:
        cur = q.popleft()
        print(f"depth = {cur.depth}, val = {cur.node.val}")

        if cur.node.left is not None:
            q.append(State(cur.node.left, cur.depth + 1))
        if cur.node.right is not None:
            q.append(State(cur.node.right, cur.depth + 1))`
    },
    {
      label: "java",
      language: "java",
      code: `class State {
    TreeNode node;
    int depth;
    State(TreeNode node, int depth) {
        this.node = node;
        this.depth = depth;
    }

}

void levelOrderTraverse(TreeNode root) {
if (root == null) return;
Queue<State> q = new LinkedList<>();
q.offer(new State(root, 1));
while (!q.isEmpty()) {
State cur = q.poll();
System.out.println("depth = " + cur.depth + ", val = " + cur.node.val);
if (cur.node.left != null)
q.offer(new State(cur.node.left, cur.depth + 1));
if (cur.node.right != null)
q.offer(new State(cur.node.right, cur.depth + 1));
}
}`    },
    {
      label: "javascript",
      language: "javascript",
      code:`class State {
constructor(node, depth) {
this.node = node;
this.depth = depth;
}
}

function levelOrderTraverse(root) {
if (root === null) return;
let q = [new State(root, 1)];
while (q.length > 0) {
let cur = q.shift();
console.log(\`depth = \${cur.depth}, val = \${cur.node.val}\`);
if (cur.node.left) q.push(new State(cur.node.left, cur.depth + 1));
if (cur.node.right) q.push(new State(cur.node.right, cur.depth + 1));
}
}`    },
    {
      label: "go",
      language: "go",
      code:`type State struct {
Node \*TreeNode
Depth int
}

func levelOrderTraverse(root _TreeNode) {
if root == nil {
return
}
q := []State{{Node: root, Depth: 1}}
for len(q) > 0 {
cur := q[0]
q = q[1:]
fmt.Printf("depth = %d, val = %d\\n", cur.Depth, cur.Node.Val)
if cur.Node.Left != nil {
q = append(q, State{Node: cur.Node.Left, Depth: cur.Depth + 1})
}
if cur.Node.Right != nil {
q = append(q, State{Node: cur.Node.Right, Depth: cur.Depth + 1})
}
}
}`    },
    {
      label: "cpp",
      language: "cpp",
      code:`struct State {
TreeNode_ node;
int depth;
State(TreeNode\* n, int d) : node(n), depth(d) {}
};

void levelOrderTraverse(TreeNode\* root) {
if (root == nullptr) return;
queue<State> q;
q.push(State(root, 1));
while (!q.empty()) {
State cur = q.front();
q.pop();
cout << "depth = " << cur.depth << ", val = " << cur.node->val << endl;
if (cur.node->left) q.push(State(cur.node->left, cur.depth + 1));
if (cur.node->right) q.push(State(cur.node->right, cur.depth + 1));
}
}`
}
]}
/>

Soon you will learn that this kind of weighted edge problem belongs to graph algorithms. You will use this method in BFS exercises and Dijkstra's algorithm.

## Other Traversal Methods?

There are only these two ways to traverse a binary tree. Other code may look different (e.g., using a stack to simulate recursion), but the core idea is always one of these two methods.

In short, don't be fooled by appearances. Once you master these two patterns, brute-force algorithms will become much easier for you.
