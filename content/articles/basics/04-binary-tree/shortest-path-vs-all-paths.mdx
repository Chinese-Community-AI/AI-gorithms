# Shortest Path vs All Paths

In real algorithm problems, the **DFS** algorithm is commonly used to enumerate **all paths**, while the **BFS** algorithm is often used to find the **shortest path**. Why is this the case?

Because recursive and level-order traversals of binary trees are the simplest forms of DFS and BFS algorithms, this article will use a simple binary tree example to illustrate the reasoning.

## Why BFS Is Often Used to Find the Shortest Path

Let's look at LeetCode problem **111: Minimum Depth of Binary Tree**. The minimum depth is the number of nodes along the shortest path from the root node down to the nearest leaf node.

Both DFS and BFS can solve this problem. Let's compare them.

### DFS Recursive Solution

The DFS approach traverses branch by branch. Every time it reaches a leaf node, it updates the minimum depth. After traversing the whole tree, you get the result.

<CodeTabs
  tabs={[
    {
      label: "python",
      language: "python",
      code: `class Solution:
    def __init__(self):
        # record the minimum depth
        self.minDepthValue = float('inf')
        # record current depth
        self.currentDepth = 0

    def minDepth(self, root: TreeNode) -> int:
        if root is None:
            return 0
        self.traverse(root)
        return self.minDepthValue

    def traverse(self, root: TreeNode) -> None:
        if root is None:
            return
        # preorder: increase depth
        self.currentDepth += 1
        # leaf node: update min depth
        if root.left is None and root.right is None:
            self.minDepthValue = min(self.minDepthValue, self.currentDepth)

        self.traverse(root.left)
        self.traverse(root.right)
        # postorder: decrease depth
        self.currentDepth -= 1`
    },
    {
      label: "java",
      language: "java",
      code: `class Solution {
    int minDepthValue = Integer.MAX_VALUE;
    int currentDepth = 0;

    public int minDepth(TreeNode root) {
        if (root == null) return 0;
        traverse(root);
        return minDepthValue;
    }

    void traverse(TreeNode root) {
        if (root == null) return;
        currentDepth++;
        if (root.left == null && root.right == null) {
            minDepthValue = Math.min(minDepthValue, currentDepth);
        }
        traverse(root.left);
        traverse(root.right);
        currentDepth--;
    }

}`    },
    {
      label: "javascript",
      language: "javascript",
      code:`var minDepth = function(root) {
if (!root) return 0;
let minDepthValue = Infinity;
let currentDepth = 0;

    const traverse = (node) => {
        if (!node) return;
        currentDepth++;
        if (!node.left && !node.right) {
            minDepthValue = Math.min(minDepthValue, currentDepth);
        }
        traverse(node.left);
        traverse(node.right);
        currentDepth--;
    };

    traverse(root);
    return minDepthValue;

};`    },
    {
      label: "go",
      language: "go",
      code:`func minDepth(root \*TreeNode) int {
if root == nil {
return 0
}
minDepthValue := math.MaxInt32
currentDepth := 0

    var traverse func(*TreeNode)
    traverse = func(node *TreeNode) {
        if node == nil {
            return
        }
        currentDepth++
        if node.Left == nil && node.Right == nil {
            if currentDepth < minDepthValue {
                minDepthValue = currentDepth
            }
        }
        traverse(node.Left)
        traverse(node.Right)
        currentDepth--
    }

    traverse(root)
    return minDepthValue

}`    },
    {
      label: "cpp",
      language: "cpp",
      code:`class Solution {
int minDepthValue = INT_MAX;
int currentDepth = 0;
public:
int minDepth(TreeNode\* root) {
if (!root) return 0;
traverse(root);
return minDepthValue;
}

    void traverse(TreeNode* root) {
        if (!root) return;
        currentDepth++;
        if (!root->left && !root->right) {
            minDepthValue = min(minDepthValue, currentDepth);
        }
        traverse(root->left);
        traverse(root->right);
        currentDepth--;
    }

};`
}
]}
/>

**Wait!** Can you finish early with DFS? No, because you must know the depth of every branch to find the smallest one.

### BFS Level-Order Solution

With BFS, since it visits level by level, as soon as it finds the **first** leaf node, it gets the minimum depth and can stop immediately.

<CodeTabs
  tabs={[
    {
      label: "python",
      language: "python",
      code: `from collections import deque

class Solution:
def minDepth(self, root: TreeNode) -> int:
if root is None:
return 0
q = deque([root]) # initialize depth to 1
depth = 1

        while q:
            sz = len(q)
            # traverse nodes of the current layer
            for _ in range(sz):
                cur = q.popleft()
                # find the first leaf node
                if cur.left is None and cur.right is None:
                    return depth
                if cur.left: q.append(cur.left)
                if cur.right: q.append(cur.right)
            depth += 1
        return depth`
    },
    {
      label: "java",
      language: "java",
      code: `class Solution {
    public int minDepth(TreeNode root) {
        if (root == null) return 0;
        Queue<TreeNode> q = new LinkedList<>();
        q.offer(root);
        int depth = 1;

        while (!q.isEmpty()) {
            int sz = q.size();
            for (int i = 0; i < sz; i++) {
                TreeNode cur = q.poll();
                if (cur.left == null && cur.right == null) {
                    return depth;
                }
                if (cur.left != null) q.offer(cur.left);
                if (cur.right != null) q.offer(cur.right);
            }
            depth++;
        }
        return depth;
    }

}`    },
    {
      label: "javascript",
      language: "javascript",
      code:`var minDepth = function(root) {
if (!root) return 0;
let q = [root];
let depth = 1;

    while (q.length > 0) {
        let sz = q.length;
        for (let i = 0; i < sz; i++) {
            let cur = q.shift();
            if (!cur.left && !cur.right) return depth;
            if (cur.left) q.push(cur.left);
            if (cur.right) q.push(cur.right);
        }
        depth++;
    }
    return depth;

};`    },
    {
      label: "go",
      language: "go",
      code:`func minDepth(root *TreeNode) int {
if root == nil {
return 0
}
q := []*TreeNode{root}
depth := 1

    for len(q) > 0 {
        sz := len(q)
        for i := 0; i < sz; i++ {
            cur := q[0]
            q = q[1:]
            if cur.Left == nil && cur.Right == nil {
                return depth
            }
            if cur.Left != nil { q = append(q, cur.Left) }
            if cur.Right != nil { q = append(q, cur.Right) }
        }
        depth++
    }
    return depth

}`    },
    {
      label: "cpp",
      language: "cpp",
      code:`class Solution {
public:
int minDepth(TreeNode* root) {
if (!root) return 0;
queue<TreeNode*> q;
q.push(root);
int depth = 1;

        while (!q.empty()) {
            int sz = q.size();
            for (int i = 0; i < sz; i++) {
                TreeNode* cur = q.front();
                q.pop();
                if (!cur->left && !cur->right) return depth;
                if (cur->left) q.push(cur->left);
                if (cur->right) q.push(cur->right);
            }
            depth++;
        }
        return depth;
    }

};`
}
]}
/>

### Summary: Shortest Path

Because BFS visits nodes level by level, the first time it finds the target node, the path it took is the **shortest path**. The algorithm can often stop early, without visiting all nodes.

In terms of time complexity, in the worst case, both algorithms visit all nodes, so both have time complexity `O(N)`. But in most cases, BFS is faster. That's why BFS is the first choice for shortest path problems.

---

## Why DFS is Commonly Used to Find All Paths

Theoretically, both DFS and BFS can find all paths. However, the code for finding all paths using BFS is more complex, while DFS is much more concise.

### Why BFS is Complex

If you want to use BFS to find all paths (from root to each leaf), the queue cannot only contain nodes. You would need to use the **Method 3** (State-based) traversal, where each `State` object stores the current node AND the full path taken to reach it. Maintaining these path strings or lists in a queue can be memory-intensive and messy.

### Why DFS is Simple

DFS inherently traverses from left to right along each branch of the tree. Each "branch" is naturally a path. When recursion reaches a leaf node, the current recursion stack (or a simple list updated during recursion) is a complete path. This makes DFS naturally suitable for finding all paths.

### Conclusion

- **DFS**: More commonly used for finding **all paths** (concise code, naturally branch-based).
- **BFS**: More commonly used for finding the **shortest path** (early stopping, level-based).
