In the previous chapter enhancing hash tables with linekd list, we used doubly linked lists to enhance 
hash tables, implementing a data structure like LinkedHashMap that maintains the insertion order of keys in a hash table.
Linked list can enhance hash tables, and arrays, being good siblings to linked lists, can also enhance hash tables. 

## Adding randomKey() API 
Now, there's a chalenge: based on the standardd hash table API, add a new randomKey() API that can 
return a random key in O(1) time complexity: 

```Java
interface Map<K, V> {
    // Get the value correspoinding to the key, time complexity O(1)
    V get(K key); 

    // Add/modify key-value pair, time complexity O(1)
    void put(K key, V value); 

    // Remvoe key-value pair, time complexity O(1)
    void remove(K key);

    // Check if the key is contained, time complexity O(1)
    boolean containKey(K key);

    // Return all keys, time complexity O(N)
    List<K> keys();

    // New API: Randomly return a key, required time complexity O(1)
    K randomKey();
}
```

Uniform Random
Note that when we talk about "random", we usually mean uniform random, which means every element has the same chance to be picked. For example, if you have n elements, your random algorithm should make sure each element is picked with probability 1/n. Only then it is called uniform random.

So, can you solve this? Don't underestimate this simple requirement. The way to do it is actually clever.

From what you learned before, you know that a hash table is basically a table array. Now, if you want to randomly return a key from a hash table, it's easy to think of picking a random element from the array.

For a normal array, picking a random element is simple. Just use a random number generator to get a random index in [0, size], and you get a random element:

```python
import random

def randomElement(arr: List[int]) -> int:
    # generate a random index in the range [0, len(arr)]
    return arr[random.randint(0, len(arr) - 1)]
```

This algorithm is correct. Its time complexity is O(1), and each element is picked with probability 1/n, where n is the length of the arr array.

But notice, this function assumes that the array is compact, with no empty spots. 
If the array has empty spots, thigns get tricky. For example, arr = [1, 2, null, 4], 
where arr[2] = null means there's no element in spot 2. If your random numner happens to be 2, waht should you do?

Maybe you would say, just search left or right to find the next non-empty element and return it, like:

```python
// return a non-null random element (pseduo code)
int randomElement(int[] arr) {
    Random r = new Random();
    // generate a random index in the range [0, arr.length]
    int i = r.nextInt(arr.length);
    while (arr[i] == null) {
        // the randomly generated index i happens to be null
        // use the circular array technique to probe to the right
        // until a non-null element is found
        i = (i + 1) % arr.length;
    }
    return arr[i];
}
```

This approahc is not feasibl, as the algorithm has two issues:
1. There is a loop, causing the wrost-case time complexity to rise to O(N), which does not meet the O(1) requirement
2. The algorithm is not uniformly random, becasue your search direction is fixed, making the elements on the right side of the gap more likely to be selected. 

Currently, the multiple random is uniformly random, but the issue is that its time complexity unexpectedly depends on random numbers! It is definitely not O(1), which doesn not meet the requirements.

Have you been stumped by the problem of randomly returning an element from an array with gaps?

Don't forget, our goal now is to randomly return a key from a hash table. The table array underlying the hash table not only contains gaps but is even more complex:

We have chaining, linear probe. 

If the hash table uses open addressing to resolve hash collisons, then you're dealing with the scenario of an array with gaps.

If your hash table uses chaining, it's more complicated. Each element in the array is a linked list, so randomly selecting an index is not enough; you also need to randomly choose a node from the linked list.
choose an array index uniformly and then a node uniformly from the linked list at the index, is the key you get uniformly random? 

Actually, it's not. In the image above, the probability of selecting k1, k2, k3 is 1/2 * 1/3 = 1/6, while the probability of selecting k4, k5 is 1/2 * 1/2 = 1/4, which is not uniformly random. 

About Probabilitstic Algorithms
Probabilistic algorithms are a very interesting class of problems. Both in algorthm probelms and real-world applications, some classic random algorithms are used. I will discuss these in more detail in Randoom Algorithms in Games and Weighted Random Selection, but for not, you don't need to master them. 

The only solution is to traverse the entire table array using the keys method, store all the keys in an array, and then randomly return on key. Howegver, this results in a complexity of O(N), which still doesn't meet the requirements. 

Feeling stuck? This is why accumulating experience in designing classic data structures is essential. If you encounter similar issues during interviews or exams, it might be difficult to come up with a solution on the spot. Next, I will introduce how to enhance a hash table with arrays to easily implement the randomKey() API. 

Implementation Idea
Earlier I talked about the chaining method to mislead you on purpose. Just like Linked List Hash Table, if you get stuck in the details, it will seem very complicated. 

So, do not get stuck in the details. Chaining and linear porbing are just to help you understand how a hash table works and why its complexity is what it is.

Now, and in the future when solving problems, just remember: a hash table is a data struture that supports key-value operations. Treat it aas a black box and do not worry about its low-level implementation. 

An array can pick a random element easily. Now, if we want to pick a random key from a hash table, the simplest way is:

```python
# pseudo-code approach 
class MyArrayHashMap:
    def __init__(self):
        # arr array stores all keys in the hash map
        self.arr = []
        self.map = {}

        # add/modify key-value pair, time complexity O(1)
        def put(self, key: int, value: int) -> None:
            if key not in self.map:
                # add the new key to the arr array
                self.arr.append(key)
            self.map[key] = value
        
        # get the value corresponding to the key, time complexity O(1)
        def get(self, key: int) -. int:
            return self.map[key]
        
        # new API: randomly return a key, requires time complexity O(1)
        def randomKey(self) -> int:
            # generete a random index in [0, len(arr)]
            return random.choice(self.arr)
        
        # delete key-value pair, time complexity O(1)
        def remove(self, key: int) -> None:
            ...
```

The idea is simple. Use an array arr to store all the keys from hash table. Then pick a key by random index. This makes sure the seletion is random, and the time complexity is O(1)

But notice, I have not implemented the remove method for the hash table. Because, to remove a key, you need to delte it from both the hash map and the array arr. Removing an element from an array takes O(N) time since you need to shift elements to keep them continuous. 

Is there a way to remove an element from arr in O(1) time without breaking the array's continuity? 

O(1) time to remove any element from an array
Yes, you can do it: swap the element you want to remove with the last element, then delte the last element. Removing the last element from an array takes O(1) time.
Of course, this will mess up the order of elements in the array. But in our case, the order does not matter, so it is fine.

For example, arr = [1, 2, 3, 4, 5]. If you want to remove 2, swap 2 with the last element:
arr = [1, 5, 3, 4, 2]. Then remove the last element 2 in O(1) time. The continuity of the array is not broken.

Does this idea make sense now?

But there is another problem. In the example above, to swap 2 to the end, you need to know its index is 1. How do you find the index of an element in the array? Normally, you have to search the array, which takes O(N) time.

But we have a hash table! what are key-value mappings for? They help you avoid searching.

So you can use a hash map to store the mapping from the array element to its index. This way, you can find the index in O(1) time.

Now, the whole idea is clear. Let's look at the code.

## Code Implementation
```python
import random
class Node:
    def __init-_(self, key, val):
        self.key = key
        self.val = val 
    
    class MyArrayHashMap:
        def __init__(self):
            # store key and the index of key in arr
            self.map = {}
            # the array that actually stores key-value pairs
            self.arr = []
        
        def get(self, key):
            if key not in self.map:
                return None
            index = self.map[key]
            return self.arr[index].val
        
        def put(self, key, val):
            if self.containsKey(key):
                # modify 
                i = self.map[key]
                self.arr[i].val = val
            # add new
            self.arr.append(Node(key, val))
            self.map[key] = len(self.arr) - 1
        
        def remove(self, key):
            if key not in self.map:
                return
            index = self.map[key]
            node = self.arr[index]

            # 1. swap the last element e with the element at index position ndoe
            etc. 
```

With this, the ArrayHashMap structure is done. If you want to build an ArrayHashSet, just wrap ArrayHashMap. I will not show the code here.

