In the previous article Principles of Hash Tables, we discussed that you cannot reply on the order of keys when looping through a hash table.
The keys in a hash table are unordered. 
But based on your programming expeirence, you may have some questions.
For example, if you use Python, you might know that since Python 3.7, the standard hash table dict guarantees that the keys will be returned in the order you inserted them.
For example, look at this code:

```python 
d = dict()
d['a'] = 1
d['b'] = 2
d['c'] = 3
print(list(d.keys())) # ['a', 'b', 'c']

d['y'] = 4
print(list(d.keys())) # ['a', 'b', 'c', 'y']

d['d'] 5 
print(list(d.keys())) # ['a', 'b', 'c', 'y', 'd']
```

No matter how many keys you insert, the keys method returns them in the same order you added them. It feels like adding elements to the end of an array. How is this possible? 
If you use Golang, you might see something even more interesting. Look at this test code: 
    
skipped golang code 

In other words, the order of traversal is random each time. But as mentioned before in How Hash Table Work, eventhough the keys in a hash table are unordered, if you don't change thetable, the traversal order should stay the same. So why does Golang's map give a different order every time? Isn't this strange? 
You can think about the reason first. Below is the answer. 
The reason the order is different everytime is because it is designed that wahy on purpose.
This reason is a bit funny. Golong wants to stop developer from depending on the order of hash table traversal. So it returns a different order on purpose each time you loop through a map. This design shows that many develoer have not learned the basic of hash tables. 
Let's think more deeply. How does it shuffle the order? Is it really random? 
Actually, no. If you look closely, the "random" order follows a pattern. Do you remember the Circular Array we talked about before? 
If there is no resizing of the table, the order of traversal is actually fixed. It just doesn't always start from the start of the underlying table array. Instead, it starts from a random possition, then uses the circular array trick to go through the whole table array. This way, the orderv looks random each time, but performance is not just to make it random. 
Now let's talk about Python. Python can keep all the keys in isnertion order because it combines a standard hash table with a linke dlist, creawting a new data structure: a hash linked list.

Other languages have similar structures, like Java's LinkedHashMap. This data structure keeps the O(1) performance of hash tables for add, remove, and search, and also keeps the insertion ordder like an array or linekd list.
How does it do that? I will explain more below. 
How to implement a hash Linked List? (LinkedHashMap) 
Let's first make the problem clear. 
In a standard hash table, the keys are stored unorderd in the undelrying table array:  

From this image, you can't tell in whawt order the keys were inserted. Once resizing happens, the position of the keys will change again. 

Now we want to be able to access all the keys in the order they were inserted, and not be affected by resizing, while keeping the tiem complexity for add, delete, search, and update the same as a normal hash table. 
 
A direct idea is to link all key-value pairs together using a structure like linked list nodes. We keep references to both the ehad and tail nodes (head, tail). Every time we insert a new key into the table array, we also insert this key at the end of the linked list.
With this, as long as we start from the head node and go through the linekd list, we can visit all keys in the order they were inserted: 

Focus on the concept, not the detials 
Some readers may get confused: Didn't we already use a linekd list to resolve hash collions in the chaining method? Now are we adding another linked list on top of that? How does this even work? 
That's why I always say you need to think abastractly. All data structures are built on arrays and linked lists. If you add more layers, it may look confusing.
If you have these questions, it's probably because your mind is stuck on the low-level details of chaining, linear probing, and so on from previous chapters, and you can't get out of the details.

Try to look at it in an abstract way: A hash tabel is basically a key-value mapping; a linked list is just a containter that stores elements in orde.  
Now, I want the keys in the hash table to be ordered by their insertion order. How can we combien the hash table and linked list? 

Suppose both the key and value are strings. A standard hash table looks like this:

In this way, we have built a hash linked list structure:
We can still find the corresponding doubly linked list node by key in O(1) time, and then get the value.
We can insert a new key-value pair in O(1) time. This is because both hash table insertion and doubly linked list head/tail insertion are O(1).
We can delete a specified key-value pair in O(1) time. Hash table deletion is O(1), and deleting a given doublly linked list node is also O(1).
Since the order of the linked list nodes is the same azs the insertion order, we can visit all keys in insertion order by traversing the linked list from the head.
In other words, we can visit all the keys ininsertion order without changing the basic tiem complexity of a standard hash table. 

Is deleting a linked list node really O(1)?
Some readers might remember that in Linked List Basics, we said that deleting a linked list node has time complexity O(n). Why is it O(1) here?
Actually, what I said here is very previse. I mean delting a given doubly linked list node is O(1).  
Before, when we implemented a linked list, we deleted a node by its idnex, which is O(n) becasue we first need to find the nody by traversing the list.
But here, there is no traversal. We get the node directly from the hash table usign the key, so it is O(1).
And in a doubly llinked list, we only need to do some simple pointer changes to delete a node, which is also O(1): 
So deleting a node in a hash linked list is till O(1).
Note that the doubly linked list node has both a previous and a next pointer, which makes O(1) deletion possible. 
A singly linked list node only has a next pointer, not a previous pointer, so it cannot do O(1) deletion.
So, when implementing a hash linked list, we must use a doubly linked list.

## Code Implementation
Now that we undersatnd the principle of hash linked lists, let's look at the coe. It is quite simple:
```python
class MyLinkedHashMap:
    class Node:
        def __init__(self, key, value):
            self.key = key
            self.val = val 
            self.next = None
            self.prev = None 
        def __init__(self):
            self.head = self.Node(None, None)
            self.tail = self.Node(None, None)
            self.head.next = self.tail 
            self.tail.prev = self.head 
            self.map = dict() 
        
        def get(self, key):
            if key not in self.map:
                return None 
            return self.map[key].val 
        
        def put(self, key, val):
            # If it is a newly inserted node, insert it into both the linked list and the map 
            if key not in self.map:
                # Insert a new node 
                ndoe = self.Node(self, val) 
                self.add_last_noe(node) 
                self.map[key] = node 
                return 
            # If it exists, repalce the previous val 
            self.map[key].val = val 
        
        def remove(self, key):
            # If the key does not exist, return directly 
            if key not in self.map:
                return 
            # If the key exists, ti needs to be deleted from both the hash table and the linked list 
            node = self.map[key]
            del self.map[key]
            self.remove_node(node)
        
        def contains_key(self, key):
            return key in self.map 
         
        def keys(self):
            key_list = []
            p = self.head.next 
            while p != self.tail: 
                key_list.append(p.key)
                p = p.next 
            return key_list 
    
        def add_last_node(self, x):
            temp = self.tail.prev 
            # temp <-> tail 
        
            x.next = self.tail 
            x.prev = temp 
            # tem <- x -> tail 
            
            temp.next = x 
            self.tail.prev = x 
            # temp <-> x <-> tail 
            
        def remove_node(self, x):
            prev = x.prev 
            next = x.next 
            # prev <-> x <-> next 
            
            prev.next = next 
            next.prev = prev 

            x.next = x.prev = None 
if __name__ == "__main__":
    map = MyLinkedHashMap() 
    map.put("a", 1) 
    map.put("b", 2) 
    map.put("c", 3) 
    map.put("d", 4) 
    map.put("e", 5) 
    
    print(map.keys()) # ['a', 'b', 'c', 'd', 'e'] 
    map.remove("b")  
    print(map.keys()) # ['a', 'c', 'd', 'e']   

# How LinkedHashSet is Implemented 
LinkedHashSet is a hash set that keeps the insertion order. 

So here, LinkedHashSet can be built by simply wrapping MyLinkedHashMap. It's very simple, so I won't write the code here. 


        