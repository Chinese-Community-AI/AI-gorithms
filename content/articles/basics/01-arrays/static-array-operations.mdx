The main job of a data structure is to add, delete, search, and update elements.

Earlier, we talked about the basic idea behind arrays and mainly explained how to read or change the value at a given indexâ€”that is, "query" and "update". Now, let's see how "add" and "delete" are done in arrays.

## Add

Adding elements to a static array can be tricky, depending on where you want to add them.

### Case 1: Append an element to the end

If you have an array of size 10 with 4 elements and want to add a new element at the end, just set the value at the next available index.

<CodeTabs
  tabs={[
    {
      label: "java",
      language: "java",
      code: `// An array of size 10 already has 4 elements
int[] arr = new int[10];
for (int i = 0; i < 4; i++) {
    arr[i] = i;
}

// Append element 4 to the end
arr[4] = 4;

// Append element 5 to the end
arr[5] = 5;`    },
    {
      label: "cpp",
      language: "cpp",
      code:`// An array of size 10 already has 4 elements
int arr[10];
for (int i = 0; i < 4; i++) {
arr[i] = i;
}

// Append element 4 to the end
arr[4] = 4;

// Append element 5 to the end
arr[5] = 5;`    },
    {
      label: "python",
      language: "python",
      code:`# An array of size 10 already has 4 elements
arr = [0] \* 10
for i in range(4):
arr[i] = i

# Append element 4 to the end

arr[4] = 4

# Append element 5 to the end

arr[5] = 5`    },
    {
      label: "go",
      language: "go",
      code:`// An array of size 10 already has 4 elements
var arr [10]int
for i := 0; i < 4; i++ {
arr[i] = i
}

// Append element 4 to the end
arr[4] = 4

// Append element 5 to the end
arr[5] = 5`    },
    {
      label: "javascript",
      language: "javascript",
      code:`// An array of size 10 already has 4 elements
let arr = new Array(10).fill(0);
for (let i = 0; i < 4; i++) {
arr[i] = i;
}

// Append element 4 to the end
arr[4] = 4;

// Append element 5 to the end
arr[5] = 5;`
}
]}
/>

Since we're just setting a value at a specific index, appending an element to the end takes **O(1)** time.

### Case 2: Insert an element in the middle

If you have an array of size 10 with 4 elements and want to insert a new element at index 2, you need to "move data" to make space. The steps are:

<CodeTabs
  tabs={[
    {
      label: "java",
      language: "java",
      code: `// An array of size 10 has 4 elements
int[] arr = new int[10];
for (int i = 0; i < 4; i++) {
    arr[i] = i;
}

// Insert element 666 at index 2
// Move elements from index 2 onwards one step back
// Traverse in reverse order to avoid overwriting
for (int i = 4; i > 2; i--) {
arr[i] = arr[i - 1];
}

// Now index 2 is empty, insert the new element
arr[2] = 666;`    },
    {
      label: "cpp",
      language: "cpp",
      code:`// An array of size 10 has 4 elements
int arr[10];
for (int i = 0; i < 4; i++) {
arr[i] = i;
}

// Insert element 666 at index 2
// Move elements from index 2 onwards one step back
// Traverse in reverse order to avoid overwriting
for (int i = 4; i > 2; i--) {
arr[i] = arr[i - 1];
}

// Now index 2 is empty, insert the new element
arr[2] = 666;`    },
    {
      label: "python",
      language: "python",
      code:`# An array of size 10 has 4 elements
arr = [0] \* 10
for i in range(4):
arr[i] = i

# Insert element 666 at index 2

# Move elements from index 2 onwards one step back

# Traverse in reverse order to avoid overwriting

for i in range(4, 2, -1):
arr[i] = arr[i - 1]

# Now index 2 is empty, insert the new element

arr[2] = 666`    },
    {
      label: "go",
      language: "go",
      code:`// An array of size 10 has 4 elements
var arr [10]int
for i := 0; i < 4; i++ {
arr[i] = i
}

// Insert element 666 at index 2
// Move elements from index 2 onwards one step back
// Traverse in reverse order to avoid overwriting
for i := 4; i > 2; i-- {
arr[i] = arr[i - 1]
}

// Now index 2 is empty, insert the new element
arr[2] = 666`    },
    {
      label: "javascript",
      language: "javascript",
      code:`// An array of size 10 has 4 elements
let arr = new Array(10).fill(0);
for (let i = 0; i < 4; i++) {
arr[i] = i;
}

// Insert element 666 at index 2
// Move elements from index 2 onwards one step back
// Traverse in reverse order to avoid overwriting
for (let i = 4; i > 2; i--) {
arr[i] = arr[i - 1];
}

// Now index 2 is empty, insert the new element
arr[2] = 666;`
}
]}
/>

Inserting an element in the middle takes **O(N)** time because you have to shift elements to make space.

### Case 3: The array is full

When you create a static array, its size is fixed. If you create `int arr[10]` (a 40-byte block) and store 10 elements, what if you want to add one more? There's no room.

Some may think: "Just add 4 more bytes after the 40 bytes, right?"

That won't work. A block of continuous memory must be allocated all at once. You can't simply grow it later. The space after your array may be used by another program.

So, what should we do? You need to get a new, bigger block of memory, copy the original data there, and then add the new element. This is called "expanding" the array.

For example, create a new, larger array `int arr[20]`. Copy over the old 10 elements. Now there's room for more.

<CodeTabs
  tabs={[
    {
      label: "java",
      language: "java",
      code: `// The array of size 10 is already full
int[] arr = new int[10];
for (int i = 0; i < 10; i++) {
    arr[i] = i;
}

// Want to append element 10, but array is full
// Need to expand the array first
int[] newArr = new int[20];

// Copy the original 10 elements over
for (int i = 0; i < 10; i++) {
newArr[i] = arr[i];
}

// Append the new element in the new larger array
newArr[10] = 10;`    },
    {
      label: "cpp",
      language: "cpp",
      code:`// The array of size 10 is already full
int arr[10];
for (int i = 0; i < 10; i++) {
arr[i] = i;
}

// Want to append element 10, but array is full
// Need to expand the array first
int newArr[20];

// Copy the original 10 elements over
for (int i = 0; i < 10; i++) {
newArr[i] = arr[i];
}

// Append the new element in the new larger array
newArr[10] = 10;`    },
    {
      label: "python",
      language: "python",
      code:`# The array of size 10 is already full
arr = [i for i in range(10)]

# Want to append element 10, but array is full

# Need to expand the array first

newArr = [0] \* 20

# Copy the original 10 elements over

for i in range(10):
newArr[i] = arr[i]

# Append the new element in the new larger array

newArr[10] = 10`    },
    {
      label: "go",
      language: "go",
      code:`// The array of size 10 is already full
var arr [10]int
for i := 0; i < 10; i++ {
arr[i] = i
}

// Want to append element 10, but array is full
// Need to expand the array first
var newArr [20]int

// Copy the original 10 elements over
for i := 0; i < 10; i++ {
newArr[i] = arr[i]
}

// Append the new element in the new larger array
newArr[10] = 10`    },
    {
      label: "javascript",
      language: "javascript",
      code:`// The array of size 10 is already full
let arr = new Array(10);
for (let i = 0; i < 10; i++) {
arr[i] = i;
}

// Want to append element 10, but array is full
// Need to expand the array first
let newArr = new Array(20).fill(0);

// Copy the original 10 elements over
for (let i = 0; i < 10; i++) {
newArr[i] = arr[i];
}

// Append the new element in the new larger array
newArr[10] = 10;`
}
]}
/>

Expanding an array means creating a new bigger array and copying all the values, which takes **O(N)** time.

## Delete

Deleting elements is similar to adding elements. Different situations need different approaches.

### Case 1: Delete the last element

If you have an array of size 10 with 5 elements and want to delete the last element, just set it to a special value to mark it as deleted. For this example, we'll use -1 as the special value. When we talk about dynamic arrays later, we'll learn better ways to delete elements.

<CodeTabs
  tabs={[
    {
      label: "java",
      language: "java",
      code: `// An array of size 10 has 5 elements
int[] arr = new int[10];
for (int i = 0; i < 5; i++) {
    arr[i] = i;
}

// Remove the last element
// Use -1 to represent the deleted element
arr[4] = -1;`    },
    {
      label: "cpp",
      language: "cpp",
      code:`// An array of size 10 has 5 elements
int arr[10];
for (int i = 0; i < 5; i++) {
arr[i] = i;
}

// Remove the last element
// Use -1 to represent the deleted element
arr[4] = -1;`    },
    {
      label: "python",
      language: "python",
      code:`# An array of size 10 has 5 elements
arr = [0] \* 10
for i in range(5):
arr[i] = i

# Remove the last element

# Use -1 to represent the deleted element

arr[4] = -1`    },
    {
      label: "go",
      language: "go",
      code:`// An array of size 10 has 5 elements
var arr [10]int
for i := 0; i < 5; i++ {
arr[i] = i
}

// Remove the last element
// Use -1 to represent the deleted element
arr[4] = -1`    },
    {
      label: "javascript",
      language: "javascript",
      code:`// An array of size 10 has 5 elements
let arr = new Array(10).fill(0);
for (let i = 0; i < 5; i++) {
arr[i] = i;
}

// Remove the last element
// Use -1 to represent the deleted element
arr[4] = -1;`
}
]}
/>

Deleting the last element is just a random access operation, which takes **O(1)** time.

### Case 2: Delete an element in the middle

If you have an array of size 10 with 5 elements and want to delete the element at index 1, you need to "move data". Move all elements after the deleted one forward by one position.

<CodeTabs
  tabs={[
    {
      label: "java",
      language: "java",
      code: `// An array of size 10 has 5 elements
int[] arr = new int[10];
for (int i = 0; i < 5; i++) {
    arr[i] = i;
}

// Delete arr[1]
// Move all elements after arr[1] one position forward
// Traverse forward to avoid overwriting
for (int i = 1; i < 4; i++) {
arr[i] = arr[i + 1];
}

// Set the last element to -1 to indicate deletion
arr[4] = -1;`    },
    {
      label: "cpp",
      language: "cpp",
      code:`// An array of size 10 has 5 elements
int arr[10];
for (int i = 0; i < 5; i++) {
arr[i] = i;
}

// Delete arr[1]
// Move all elements after arr[1] one position forward
// Traverse forward to avoid overwriting
for (int i = 1; i < 4; i++) {
arr[i] = arr[i + 1];
}

// Set the last element to -1 to indicate deletion
arr[4] = -1;`    },
    {
      label: "python",
      language: "python",
      code:`# An array of size 10 has 5 elements
arr = [0] \* 10
for i in range(5):
arr[i] = i

# Delete arr[1]

# Move all elements after arr[1] one position forward

# Traverse forward to avoid overwriting

for i in range(1, 4):
arr[i] = arr[i + 1]

# Set the last element to -1 to indicate deletion

arr[4] = -1`    },
    {
      label: "go",
      language: "go",
      code:`// An array of size 10 has 5 elements
var arr [10]int
for i := 0; i < 5; i++ {
arr[i] = i
}

// Delete arr[1]
// Move all elements after arr[1] one position forward
// Traverse forward to avoid overwriting
for i := 1; i < 4; i++ {
arr[i] = arr[i + 1]
}

// Set the last element to -1 to indicate deletion
arr[4] = -1`    },
    {
      label: "javascript",
      language: "javascript",
      code:`// An array of size 10 has 5 elements
let arr = new Array(10).fill(0);
for (let i = 0; i < 5; i++) {
arr[i] = i;
}

// Delete arr[1]
// Move all elements after arr[1] one position forward
// Traverse forward to avoid overwriting
for (let i = 1; i < 4; i++) {
arr[i] = arr[i + 1];
}

// Set the last element to -1 to indicate deletion
arr[4] = -1;`
}
]}
/>

Deleting an element in the middle takes **O(N)** time because you have to move elements to keep everything in order.

## Summary

The time complexity for the main operations of static arrays:

**Add:**

- Add an element at the end: **O(1)**
- Insert an element in the middle: **O(N)**

**Delete:**

- Remove the last element: **O(1)**
- Remove an element from the middle: **O(N)**

**Access:** Get the value at a given index: **O(1)**

**Update:** Modify the value at a given index: **O(1)**

## Important Notes

**About resizing:** When an array expands, it needs to create a new space and copy data, which takes O(N) time. Why isn't this included in the "add" operation's complexity?

Resizing doesn't happen every time you add an element. We use "amortized time complexity" to explain this. I've explained this in detail in _How to Analyze Time and Space Complexity_. I won't go further into that here.

**About search vs access:** We say access and update operations are O(1), but this is only true when you know the index. If you are given a value and asked to find its index in the array, you have to check the whole array. That takes **O(N)** time.

So, it is important to understand the principles, not just memorize the concepts. If you understand the principles, you can figure out the concepts by yourself.
