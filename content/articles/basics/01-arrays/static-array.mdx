You must decide the element type and size when creating a static array. Only C++, Java, and Go support true static arrays. Python and JavaScript do not.

Static arrays are low-level and rarely used in everyday coding. We usually work with dynamic arrays instead. But understanding static arrays is important—they form the foundation for everything else.

Here's how to define a static array:

<CodeTabs
  tabs={[
    {
      label: "python",
      language: "python",
      code:`# Python does not have true static arrays

# We can use lists to simulate them

# define a list of size 10

arr = [0] \* 10

# assign values using index

arr[0] = 1
arr[1] = 2

# retrieve values using index

a = arr[0]`   },
    {
      label: "java",
      language: "java",
      code:`// Define a static array of size 10
int[] arr = new int[10];

// Assign values using index
arr[0] = 1;
arr[1] = 2;

// Retrieve values using index
int a = arr[0];`    },
    {
      label: "javascript",
      language: "javascript",
      code:`// JavaScript does not have native static arrays
// We can simulate them with Array

// define an array of size 10
let arr = new Array(10).fill(0);

// assign values using index
arr[0] = 1;
arr[1] = 2;

// retrieve values using index
let a = arr[0];`
    },
    {
      label: "go",
      language: "go",
      code:`// Define a static array of size 10
var arr [10]int

// Assign values using index
arr[0] = 1
arr[1] = 2

// Retrieve values using index
a := arr[0]`    },
    {
      label: "cpp",
      language: "cpp",
      code:`// Define a static array of size 10
int arr[10];

// Assign values using index
arr[0] = 1;
arr[1] = 2;

// Retrieve values using index
int a = arr[0];` },
]}
/>

That's it. There is not much more you can do with static arrays.

## How It Works

When you write `int arr[10]` in C++, two things happen:

1. It creates a continuous block of memory in RAM, sized at 10 × `sizeof(int)` bytes. On most systems, an `int` is 4 bytes, so the block uses 40 bytes.
2. It defines a variable `arr` that holds the starting address of this memory block.

When you write `arr[1] = 2`:

1. It calculates the address by taking the array's starting address and adding 1 × `sizeof(int)` bytes (4 bytes) to reach the second item.
2. It writes the number 2 into the 4 bytes starting at that address.

### Why Index Starts at 0

Arrays start at 0 because it simplifies address calculation. `arr[0]` is just the array's starting address. The first 4 bytes store the first item. `arr[1]` is the starting address plus 4 bytes; the next 4 bytes store the second item, and so on.

The array name `arr` is actually a pointer to the start of the memory block. Using this address directly gives you the first item: `*arr` is the same as `arr[0]`.

## Initialization

If you don't initialize the array (using something like `memset`), the values will be random. That's because `int arr[10]` only requests a memory block from the operating system—it doesn't know what was stored there before.

**Note:** This behavior is specific to C/C++. In Java or Go, the system automatically sets all new array items to 0.

---

## Basic Operations (CRUD)

The main job of a data structure is to add, delete, search, and update elements. Now that we understand how memory works, let's see how these operations are performed.

### Add

Adding elements to a static array can be tricky because its size is fixed.

#### Case 1: Append to the end

If the array has space, just set the value at the next available index. This is very fast: **O(1)**.

<CodeTabs
  tabs={[
    {
      label: "python",
      language: "python",
      code: `# Append element 4 to the end
arr[4] = 4
arr[5] = 5`,
    },
    {
      label: "java",
      language: "java",
      code: `// Append element 4 to the end
arr[4] = 4;
arr[5] = 5;`,
    },
    {
      label: "javascript",
      language: "javascript",
      code: `// Append element 4 to the end
arr[4] = 4;
arr[5] = 5;`,
    },
    {
      label: "go",
      language: "go",
      code: `// Append element 4 to the end
arr[4] = 4
arr[5] = 5`,
    },
    {
      label: "cpp",
      language: "cpp",
      code: `// Append element 4 to the end
arr[4] = 4;
arr[5] = 5;`,
    },
  ]}
/>

#### Case 2: Insert in the middle

To insert an element at index 2, you must "move data" to make space. This takes **O(N)** time because you have to shift elements.

<CodeTabs
  tabs={[
    {
      label: "python",
      language: "python",
      code: `# Insert element 666 at index 2
# Move elements from index 2 onwards one step back
for i in range(4, 2, -1):
    arr[i] = arr[i - 1]
arr[2] = 666`,
    },
    {
      label: "java",
      language: "java",
      code: `// Insert element 666 at index 2
// Move elements from index 2 onwards one step back
for (int i = 4; i > 2; i--) {
    arr[i] = arr[i - 1];
}
arr[2] = 666;`,
    },
    {
      label: "javascript",
      language: "javascript",
      code: `// Insert element 666 at index 2
// Move elements from index 2 onwards one step back
for (let i = 4; i > 2; i--) {
    arr[i] = arr[i - 1];
}
arr[2] = 666;`,
    },
    {
      label: "go",
      language: "go",
      code: `// Insert element 666 at index 2
// Move elements from index 2 onwards one step back
for i := 4; i > 2; i-- {
    arr[i] = arr[i - 1]
}
arr[2] = 666`,
    },
    {
      label: "cpp",
      language: "cpp",
      code: `// Insert element 666 at index 2
// Move elements from index 2 onwards one step back
for (int i = 4; i > 2; i--) {
    arr[i] = arr[i - 1];
}
arr[2] = 666;`,
    },
  ]}
/>

#### Case 3: The array is full (Expanding)

A static array cannot grow. If it's full and you need more space, you must allocate a new, larger block of memory and copy everything over. This "expansion" takes **O(N)** time.

<CodeTabs
  tabs={[
    {
      label: "python",
      language: "python",
      code: `# Need to expand the array
newArr = [0] \* 20
for i in range(10):
    newArr[i] = arr[i]
newArr[10] = 10`,
    },
    {
      label: "java",
      language: "java",
      code: `// Need to expand the array
int[] newArr = new int[20];
for (int i = 0; i < 10; i++) {
    newArr[i] = arr[i];
}
newArr[10] = 10;`,
    },
    {
      label: "javascript",
      language: "javascript",
      code: `// Need to expand the array
let newArr = new Array(20).fill(0);
for (let i = 0; i < 10; i++) {
    newArr[i] = arr[i];
}
newArr[10] = 10;`,
    },
    {
      label: "go",
      language: "go",
      code: `// Need to expand the array
var newArr [20]int
for i := 0; i < 10; i++ {
    newArr[i] = arr[i]
}
newArr[10] = 10`,
    },
    {
      label: "cpp",
      language: "cpp",
      code: `// Need to expand the array
int newArr[20];
for (int i = 0; i < 10; i++) {
    newArr[i] = arr[i];
}
newArr[10] = 10;`,
    },
  ]}
/>

### Delete

#### Case 1: Delete from the end

Just mark the last element as empty or decrement your count. This is **O(1)**.

<CodeTabs
  tabs={[
    {
      label: "python",
      language: "python",
      code: `# Remove the last element
arr[4] = -1`,
    },
    {
      label: "java",
      language: "java",
      code: `// Remove the last element
arr[4] = -1;`,
    },
    {
      label: "javascript",
      language: "javascript",
      code: `// Remove the last element
arr[4] = -1;`,
    },
    {
      label: "go",
      language: "go",
      code: `// Remove the last element
arr[4] = -1`,
    },
    {
      label: "cpp",
      language: "cpp",
      code: `// Remove the last element
arr[4] = -1;`,
    },
  ]}
/>

#### Case 2: Delete from the middle

To keep the array continuous, you must move all elements after the deleted one forward by one position. This takes **O(N)**.

<CodeTabs
  tabs={[
    {
      label: "python",
      language: "python",
      code: `# Delete element at index 1
for i in range(1, 4):
    arr[i] = arr[i + 1]
arr[4] = -1`,
    },
    {
      label: "java",
      language: "java",
      code: `// Delete element at index 1
for (int i = 1; i < 4; i++) {
    arr[i] = arr[i + 1];
}
arr[4] = -1;`,
    },
    {
      label: "javascript",
      language: "javascript",
      code: `// Delete element at index 1
for (let i = 1; i < 4; i++) {
    arr[i] = arr[i + 1];
}
arr[4] = -1;`,
    },
    {
      label: "go",
      language: "go",
      code: `// Delete element at index 1
for i := 1; i < 4; i++ {
    arr[i] = arr[i + 1]
}
arr[4] = -1`,
    },
    {
      label: "cpp",
      language: "cpp",
      code: `// Delete element at index 1
for (int i = 1; i < 4; i++) {
    arr[i] = arr[i + 1];
}
arr[4] = -1;`,
    },
  ]}
/>

### Access & Update

As we saw in the "How It Works" section, because arrays use continuous memory, we can jump to any index instantly. Both Access and Update take **O(1)** time.

<CodeTabs
  tabs={[
    {
      label: "python",
      language: "python",
      code: `# Access: Get the value at index 1
val = arr[1]

# Update: Change the value at index 1

arr[1] = 999`,
    },
    {
      label: "java",
      language: "java",
      code: `// Access: Get the value at index 1
int val = arr[1];

// Update: Change the value at index 1
arr[1] = 999;`,
    },
    {
      label: "javascript",
      language: "javascript",
      code: `// Access: Get the value at index 1
let val = arr[1];

// Update: Change the value at index 1
arr[1] = 999;`,
    },
    {
      label: "go",
      language: "go",
      code: `// Access: Get the value at index 1
val := arr[1]

// Update: Change the value at index 1
arr[1] = 999`,
    },
    {
      label: "cpp",
      language: "cpp",
      code: `// Access: Get the value at index 1
int val = arr[1];

// Update: Change the value at index 1
arr[1] = 999;`,
},
]}
/>

---

## Summary

The time complexity for the main operations of static arrays:

**Add:**

- Add an element at the end: **O(1)**
- Insert an element in the middle: **O(N)**

**Delete:**

- Remove the last element: **O(1)**
- Remove an element from the middle: **O(N)**

**Access:** Get the value at a given index: **O(1)**
**Update:** Modify the value at a given index: **O(1)**

### Important Notes

**About resizing:** Resizing doesn't happen every time. We use "amortized time complexity" to explain this. This is covered in detail in _How to Analyze Time and Space Complexity_.

**About search vs access:** Access and update are O(1) only when you know the **index**. If you only have a **value** and need to find where it is (search), you have to check each element one by one, which takes **O(N)** time.
