We talked about static arrays and their limitations. Now let's talk about **dynamic arrays**. A dynamic array is an upgrade of the static array, and it is one of the most commonly used data structures in real software development and algorithm problems.

First, it's important to understand: **dynamic arrays do not solve the problem of slow insert and delete operations in the middle.** That is impossible. The fast random access of an array comes from its continuous memory, which always requires moving data when the structure changes.

The underlying storage of dynamic arrays is still a static array. Dynamic arrays simply:

1. Automatically handle **resizing** for us.
2. Provide clean APIs for common operations like `add`, `delete`, `access`, and `update`.

---

## Using Dynamic Arrays

Here are some ways to use dynamic arrays in different programming languages:

<CodeTabs
  tabs={[
    {
      label: "python",
      language: "python",
      code:`# create a dynamic array
# Automatically expands and shrinks based on size
arr = []

for i in range(10): # append to end, O(1)
arr.append(i)

# insert in middle, O(N)

# insert element 666 at index 2

arr.insert(2, 666)

# insert at beginning, O(N)

arr.insert(0, -1)

# delete last element, O(1)

arr.pop()

# delete in middle, O(N)

# delete the element at index 2

arr.pop(2)

# query by index, O(1)

a = arr[0]

# modify by index, O(1)

arr[0] = 100

# find index by value, O(N)

index = arr.index(666)`    },
    {
      label: "java",
      language: "java",
      code:`// In Java, use ArrayList
ArrayList<Integer> arr = new ArrayList<>();

for (int i = 0; i < 10; i++) {
// append to end, O(1)
arr.add(i);
}

// insert element 666 at index 2, O(N)
arr.add(2, 666);

// insert at beginning, O(N)
arr.add(0, -1);

// delete last element, O(1)
arr.remove(arr.size() - 1);

// delete element at index 2, O(N)
arr.remove(2);

// query by index, O(1)
int a = arr.get(0);

// modify by index, O(1)
arr.set(0, 100);

// find index by value, O(N)
int index = arr.indexOf(666);`    },
    {
      label: "cpp",
      language: "cpp",
      code:`// In C++, use std::vector
vector<int> arr;

for (int i = 0; i < 10; i++) {
// append to end, O(1)
arr.push_back(i);
}

// insert element 666 at index 2, O(N)
arr.insert(arr.begin() + 2, 666);

// insert at beginning, O(N)
arr.insert(arr.begin(), -1);

// delete last element, O(1)
arr.pop_back();

// delete element at index 2, O(N)
arr.erase(arr.begin() + 2);

// query by index, O(1)
int a = arr[0];

// modify by index, O(1)
arr[0] = 100;

// find index by value, O(N)
auto it = find(arr.begin(), arr.end(), 666);
int index = (it != arr.end()) ? distance(arr.begin(), it) : -1;`    },
    {
      label: "go",
      language: "go",
      code:`// In Go, slices are dynamic arrays
arr := []int{}

for i := 0; i < 10; i++ {
// append to end, O(1)
arr = append(arr, i)
}

// insert element 666 at index 2, O(N)
arr = append(arr[:2], append([]int{666}, arr[2:]...)...)

// insert at beginning, O(N)
arr = append([]int{-1}, arr...)

// delete last element, O(1)
arr = arr[:len(arr)-1]

// delete element at index 2, O(N)
arr = append(arr[:2], arr[3:]...)

// query by index, O(1)
a := arr[0]

// modify by index, O(1)
arr[0] = 100

// find index by value, O(N)
index := -1
for i, v := range arr {
if v == 666 {
index = i
break
}
}`    },
    {
      label: "javascript",
      language: "javascript",
      code:`// In JS, the Array is dynamic
let arr = [];

for (let i = 0; i < 10; i++) {
// append to end, O(1)
arr.push(i);
}

// insert element 666 at index 2, O(N)
arr.splice(2, 0, 666);

// insert at beginning, O(N)
arr.unshift(-1);

// delete last element, O(1)
arr.pop();

// delete element at index 2, O(N)
arr.splice(2, 1);

// query by index, O(1)
let a = arr[0];

// modify by index, O(1)
arr[0] = 100;

// find index by value, O(N)
let index = arr.indexOf(666);`
}
]}
/>

---

## Key Implementation Concepts

To understand how a dynamic array works under the hood, pay attention to these three core logic points:

### 1. Auto Expanding and Shrinking

Static arrays have a fixed size. Dynamic arrays overcome this by:

- **Expanding:** When the underlying array is full, we double its capacity.
- **Shrinking:** When many elements are deleted, we shrink the capacity by half (typically when the count drops to 1/4 of capacity) to save memory.

### 2. Index Boundary Checks

There are two types of index checks used in implementation:

- **Element Index:** Used for `get` and `set`. Must be `0 <= index < size`.
- **Position Index:** Used for `add`. Must be `0 <= index <= size` because you can insert at the very end of the current elements (the "gap" after the last element).

### 3. Preventing Memory Leaks

In languages with garbage collection (Java, Python, JS), simply decrementing the `size` variable isn't enough when deleting an element. The reference to the deleted object remains in the underlying array, preventing the garbage collector from reclaiming its memory.
We must explicitly set deleted spots to `null` (or `None`).

---

## Dynamic Array Code Implementation

Here is how you would implement a dynamic array like `ArrayList` or `vector` from scratch. The core logic involves managing an underlying static array and handling resizing.

<CodeTabs
  tabs={[
    {
      label: "python",
      language: "python",
      code: `class MyArrayList:
    INIT_CAP = 1

    def __init__(self, init_capacity=None):
        self.data = [None] * (init_capacity if init_capacity is not None else self.INIT_CAP)
        self.size = 0

    def add_last(self, e):
        if self.size == len(self.data):
            self._resize(2 * len(self.data))
        self.data[self.size] = e
        self.size += 1

    def add(self, index, e):
        self._check_position_index(index)
        if self.size == len(self.data):
            self._resize(2 * len(self.data))
        for i in range(self.size - 1, index - 1, -1):
            self.data[i + 1] = self.data[i]
        self.data[index] = e
        self.size += 1

    def remove_last(self):
        if self.size == 0: raise Exception("NoSuchElementException")
        if self.size == len(self.data) // 4:
            self._resize(len(self.data) // 2)
        deleted_val = self.data[self.size - 1]
        self.data[self.size - 1] = None # GC
        self.size -= 1
        return deleted_val

    def remove(self, index):
        self._check_element_index(index)
        if self.size == len(self.data) // 4:
            self._resize(len(self.data) // 2)
        deleted_val = self.data[index]
        for i in range(index + 1, self.size):
            self.data[i - 1] = self.data[i]
        self.data[self.size - 1] = None # GC
        self.size -= 1
        return deleted_val

    def get(self, index):
        self._check_element_index(index)
        return self.data[index]

    def set(self, index, e):
        self._check_element_index(index)
        old_val = self.data[index]
        self.data[index] = e
        return old_val

    def _resize(self, new_cap):
        temp = [None] * new_cap
        for i in range(self.size):
            temp[i] = self.data[i]
        self.data = temp

    def _check_element_index(self, index):
        if not (0 <= index < self.size):
            raise IndexError("Index out of bounds")

    def _check_position_index(self, index):
        if not (0 <= index <= self.size):
            raise IndexError("Position out of bounds")`,
    },
    {
      label: "java",
      language: "java",
      code: `public class MyArrayList<E> {
    private E[] data;
    private int size;
    private static final int INIT_CAP = 1;

    public MyArrayList(int initCapacity) {
        data = (E[]) new Object[initCapacity];
        size = 0;
    }

    public void addLast(E e) {
        if (size == data.length) resize(2 * data.length);
        data[size++] = e;
    }

    public void add(int index, E e) {
        checkPositionIndex(index);
        if (size == data.length) resize(2 * data.length);
        for (int i = size - 1; i >= index; i--) {
            data[i + 1] = data[i];
        }
        data[index] = e;
        size++;
    }

    public E removeLast() {
        if (size == 0) throw new NoSuchElementException();
        if (size == data.length / 4) resize(data.length / 2);
        E deletedVal = data[size - 1];
        data[size - 1] = null; // GC
        size--;
        return deletedVal;
    }

    public E remove(int index) {
        checkElementIndex(index);
        if (size == data.length / 4) resize(data.length / 2);
        E deletedVal = data[index];
        for (int i = index + 1; i < size; i++) {
            data[i - 1] = data[i];
        }
        data[size - 1] = null; // GC
        size--;
        return deletedVal;
    }

    public E get(int index) {
        checkElementIndex(index);
        return data[index];
    }

    private void resize(int newCap) {
        E[] temp = (E[]) new Object[newCap];
        System.arraycopy(data, 0, temp, 0, size);
        data = temp;
    }

    private void checkElementIndex(int index) {
        if (index < 0 || index >= size) throw new IndexOutOfBoundsException();
    }

    private void checkPositionIndex(int index) {
        if (index < 0 || index > size) throw new IndexOutOfBoundsException();
    }

}`,
    },
    {
      label: "cpp",
      language: "cpp",
      code: `template <typename T>
class MyArrayList {
private:
T\* data;
int size;
int cap;

    void resize(int newCap) {
        T* temp = new T[newCap];
        for (int i = 0; i < size; i++) temp[i] = data[i];
        delete[] data;
        data = temp;
        cap = newCap;
    }

public:
MyArrayList(int initCap = 1) : size(0), cap(initCap) {
data = new T[cap];
}

    ~MyArrayList() { delete[] data; }

    void addLast(T e) {
        if (size == cap) resize(2 * cap);
        data[size++] = e;
    }

    void add(int index, T e) {
        if (index < 0 || index > size) throw std::out_of_range("Index out of bounds");
        if (size == cap) resize(2 * cap);
        for (int i = size - 1; i >= index; i--) data[i + 1] = data[i];
        data[index] = e;
        size++;
    }

    T removeLast() {
        if (size == 0) throw std::underflow_error("Empty");
        if (size == cap / 4) resize(cap / 2);
        return data[--size];
    }

    T get(int index) {
        if (index < 0 || index >= size) throw std::out_of_range("Index out of bounds");
        return data[index];
    }

};`,
    },
    {
      label: "go",
      language: "go",
      code: `type MyArrayList[T any] struct {
data []T
size int
}

func NewMyArrayList[T any](initCap int) \*MyArrayList[T] {
return &MyArrayList[T]{data: make([]T, initCap), size: 0}
}

func (l _MyArrayList[T]) AddLast(e T) {
if l.size == len(l.data) {
l.resize(2 _ len(l.data))
}
l.data[l.size] = e
l.size++
}

func (l \*MyArrayList[T]) RemoveLast() T {
if l.size == 0 { panic("empty") }
if l.size == len(l.data)/4 {
l.resize(len(l.data) / 2)
}
val := l.data[l.size-1]
var zero T
l.data[l.size-1] = zero // GC
l.size--
return val
}

func (l \*MyArrayList[T]) resize(newCap int) {
newData := make([]T, newCap)
copy(newData, l.data[:l.size])
l.data = newData
}`,
    },
    {
      label: "javascript",
      language: "javascript",
      code: `class MyArrayList {
constructor(initCapacity = 1) {
this.data = new Array(initCapacity);
this.size = 0;
}

    addLast(e) {
        if (this.size === this.data.length) this._resize(2 * this.data.length);
        this.data[this.size++] = e;
    }

    removeLast() {
        if (this.size === 0) throw new Error("Empty");
        if (this.size === Math.floor(this.data.length / 4)) {
            this._resize(Math.floor(this.data.length / 2));
        }
        const val = this.data[--this.size];
        this.data[this.size] = undefined; // GC
        return val;
    }

    _resize(newCap) {
        let temp = new Array(newCap);
        for (let i = 0; i < this.size; i++) temp[i] = this.data[i];
        this.data = temp;
    }

}`,
},
]}
/>

### How to Verify Your Implementation?

You can use LeetCode problem 707, **"Design Linked List"**, to verify the correctness of your implementation. Although the problem name mentions linked lists, you can implement the required functions using your dynamic array logic to pass the test cases.
